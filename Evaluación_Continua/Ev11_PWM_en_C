//  Código PWM forzado:
// Victoria Etcheverry, Guadalupe Sosa y Sofía Modernell

// Librerias utilizadas 
#include <avr/io.h>
#include <util/delay.h>

// Definiciones
#define F_CPU 16000000UL // Frecuencia 
#define TOP 255 // Valor máximo para PWM 
#define PASOS 200 // Número de pasos para la rampa (brillo)
#define VELOCIDAD_RAMPA 100 // Controla la velocidad de la rampa (brillo)

int main(void) {
    DDRB |= (1<<PB1) | (1<<PB2); // LED1=D9, LED2=D10

    uint16_t paso = 0; // Controla los pasos de la rampa
    uint8_t dir_up = 1; // dirección: 1= ascendente, 0= descendnete
    uint16_t contador_lento = 0; // relentiza

    uint16_t dutyA = 0;
    uint16_t dutyB = TOP;

    while(1) {
        contador_lento++;
        if(contador_lento >= VELOCIDAD_RAMPA) {
            contador_lento = 0;

            // duty proporcional al paso actual
            dutyA = (TOP * paso) / PASOS;
            dutyB = (TOP * (PASOS - paso)) / PASOS;

            // Actualiza el paso de la rampa según la dirección 
            if(dir_up){
                if(++paso >= PASOS){ paso = PASOS; dir_up = 0; }
            } else {
                if(paso-- == 0){ 
                    paso = 0; 
                    dir_up = 1; }
            // si llega al final limita el paso y cambia de dirección 
            }
        }

        // PWM frozado rápido 
        for(uint16_t cnt=0; cnt<=TOP; cnt++){
            // LED1: encendido si cnt < dutyA, apagado si cnt >= dutyA 
            if(cnt < dutyA) PORTB |= (1<<PB1); else PORTB &= ~(1<<PB1);
            // LED2: encendido si cnt < dutyB, apagado si cnt >= dutyB
            if(cnt < dutyB) PORTB |= (1<<PB2); else PORTB &= ~(1<<PB2);
            _delay_us(1); // mantiene PWM rápida
        }
    }
}

// Código para Fast PWM:

#include <avr/io.h>
#include <util/delay.h>

#define F_CPU 16000000UL
#define TOP 255        
#define PASOS 200      

int main(void) {
    DDRB |= (1<<PB1) | (1<<PB2); // LED1 y LED2

    // Timer1 para Fast PWM 8-bit
    TCCR1A = (1<<COM1A1) | (1<<COM1B1) | (1<<WGM11); // modo Fast PWM
    TCCR1B = (1<<WGM13) | (1<<WGM12) | (1<<CS11); // Prescaler 8
    ICR1 = TOP; // valor máximo del contador

    uint16_t paso = 0;
    uint8_t dir_up = 1;

    // Contador para velocidad rampa
    uint16_t contador_lento = 0;
    const uint16_t velocidad_rampa = 500; // aumentar = más lento

    while(1) {
        contador_lento++;
        if (contador_lento >= velocidad_rampa) {
            contador_lento = 0;

            // Calcula duty complementario
            uint16_t dutyA = (TOP * paso) / PASOS;
            uint16_t dutyB = (TOP * (PASOS - paso)) / PASOS;

            // Asigna duty al Fast PWM
            OCR1A = dutyA;
            OCR1B = dutyB;

            // Avanza rampa
            if(dir_up){
                if(++paso >= PASOS){ paso = PASOS; dir_up = 0; }
            } else {
                if(paso-- == 0){ paso = 0; dir_up = 1; }
            }
        }

        _delay_ms(1); // pequeño delay para mantener bucle
    }
}

