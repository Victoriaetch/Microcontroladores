#define PCF8574 0x27 // Dirección del módulo 

#define F_CPU 16000000UL // Frecuencia del microcontrolador

#include <avr/io.h> 
#include <util/delay.h>
#include <string.h>
#include <avr/eeprom.h>
#include "twi_lcd.h" // Libería para manejar la LCD mediante I2C

#define EEPROM_ADDR_CLAVE 0x00 // Dirección inicial en EEPROM para guardar la clave

// Configuración de tamaño máximo de la clave y teclado
#define MAX_CLAVE 6
#define ROWS 4
#define COLS 4

// Definición de la matriz de teclas del keypad
char keys[ROWS][COLS] = {
	{'1','2','3','A'},
	{'4','5','6','B'},
	{'7','8','9','C'},
	{'*','0','#','D'}
};
// Pines conectados a las filas y columnas del keypad
uint8_t rowPins[ROWS] = {PC0, PC1, PC2, PC3};
uint8_t colPins[COLS] = {PD2, PD3, PD4, PD6};

// Función para guardar clave en la EEPROM
void guardar_clave_EEPROM(char *clave) {
	eeprom_write_block((const void*)clave, (void*)EEPROM_ADDR_CLAVE, MAX_CLAVE);
}

// Función para leer clave desde la EEPROM
void leer_clave_EEPROM(char *clave) {
	eeprom_read_block((void*)clave, (const void*)EEPROM_ADDR_CLAVE, MAX_CLAVE);
}

// Inicialización del teclado matricial
void keypad_init(void) {
	// Configura filas como salidas y las pone en alto
	DDRC |= (1<<PC0)|(1<<PC1)|(1<<PC2)|(1<<PC3);
	PORTC |= (1<<PC0)|(1<<PC1)|(1<<PC2)|(1<<PC3);
	// Configura columnas como entradas con pull-up
	DDRD &= ~((1<<PD2)|(1<<PD3)|(1<<PD4)|(1<<PD6));
	PORTD |= (1<<PD2)|(1<<PD3)|(1<<PD4)|(1<<PD6);
}

// Lectura de la tecla presionada
char keypad_getkey(void) {
	// Pone todas las filas en alto
	for (uint8_t r=0;r<ROWS;r++){
		PORTC |= (1<<PC0)|(1<<PC1)|(1<<PC2)|(1<<PC3);
		// Baja la fila actual
		PORTC &= ~(1<<rowPins[r]);
		for(uint8_t c=0;c<COLS;c++){
			// Si columna detecta presión (LOW)
			if(!(PIND & (1<<colPins[c]))){
				_delay_ms(50);
				while(!(PIND & (1<<colPins[c]))); // espera a soltar
				return keys[r][c];// devuelve tecla
			}
		}
	}
	return 0 // ninguna tecla presionada
}

// Función para ingresar la clave y validarla
uint8_t ingresar_clave(char *clave_guardada, uint8_t max_len) {
	char clave_ingresada[MAX_CLAVE+1];
	uint8_t index;
	char key;

	while(1) {  
		index = 0;
		memset(clave_ingresada, 0, MAX_CLAVE+1);
		twi_lcd_clear();
		twi_lcd_cmd(0x80);
		twi_lcd_msg("Ingrese clave:");
		twi_lcd_cmd(0xC0);

		while(1) { 
			key = keypad_getkey();
			if(key) {
				if(key == '#') { // confirmar
					if(index < 4){ // mínimo 4 dígitos
						twi_lcd_clear();
						twi_lcd_cmd(0x80);
						twi_lcd_msg("Min 4 digitos");
						_delay_ms(1500);
						break;  // reinicia ingreso
					}
					// comparar clave
					if(strcmp(clave_ingresada, clave_guardada) == 0) return 1; // correcta
					else return 0; // incorrecta
				}

				if(key == 'A') {  // borra el último dígito
					if(index > 0) index--;
					clave_ingresada[index] = '\0';
				}
				else if(index < 6) {  // máximo 6 dígitos
					clave_ingresada[index++] = key;
					clave_ingresada[index] = '\0';
				}
				// Actualiza LCD con asteriscos
				twi_lcd_cmd(0xC0);
				twi_lcd_clear();
				twi_lcd_cmd(0x80);
				twi_lcd_msg("Ingrese clave:");
				twi_lcd_cmd(0xC0);
				for(uint8_t i = 0; i < index; i++) twi_lcd_msg("*");
			}
		}
	}
}

// Función para cambiar la clave
void cambiar_clave(char *clave_guardada, uint8_t max_len) {
	char clave_actual[MAX_CLAVE+1] = {0};
	char clave_nueva[MAX_CLAVE+1] = {0};
	uint8_t index;
	char key;

	// Ingreso de clave actual
	index = 0;
	twi_lcd_clear();
	twi_lcd_cmd(0x80);
	twi_lcd_msg("Clave actual:");
	twi_lcd_cmd(0xC0);

	while(1){
		key = keypad_getkey();
		if(key){
			if(key == '#') break;  // confirmar
			if(key == 'A'){ if(index>0) index--; clave_actual[index]='\0'; }
			else if(index < max_len) { clave_actual[index++] = key; clave_actual[index]='\0'; }

			// Actualiza LCD con asteriscos
            twi_lcd_cmd(0xC0);
			twi_lcd_clear();
			twi_lcd_cmd(0x80);
			twi_lcd_msg("Clave actual:");
			twi_lcd_cmd(0xC0);
			for(uint8_t i=0;i<index;i++) twi_lcd_msg("*");
		}
	}

	// Verifica clave actual
	if(strcmp(clave_actual, clave_guardada) != 0){
		twi_lcd_clear();
		twi_lcd_cmd(0x80);
		twi_lcd_msg("Clave incorrecta");
		_delay_ms(2000);
		return;
	}
    // Ingresa clave nueva
	while(1) { 
		index = 0;
		memset(clave_nueva, 0, MAX_CLAVE+1);
		twi_lcd_clear();
		twi_lcd_cmd(0x80);
		twi_lcd_msg("Nueva clave:");
		twi_lcd_cmd(0xC0);

		while(1){ 
			key = keypad_getkey();
			if(key){
				if(key == '#'){
					if(index < 4){ // mínimo
						twi_lcd_clear();
						twi_lcd_cmd(0x80);
						twi_lcd_msg("Min 4 digitos");
						_delay_ms(1500);
						break; // reinicia ingreso
					}
					// clave válida, se guarda
					strcpy(clave_guardada, clave_nueva);
					guardar_clave_EEPROM(clave_guardada);
					twi_lcd_clear();
					twi_lcd_cmd(0x80);
					twi_lcd_msg("Clave cambiada!");
					_delay_ms(2000);
					return;
				}

				if(key == 'A'){ if(index>0) index--; clave_nueva[index]='\0'; }
				else if(index < 6){ 
					clave_nueva[index++] = key;
					clave_nueva[index]='\0';
				}
				twi_lcd_cmd(0xC0);
				twi_lcd_clear();
				twi_lcd_cmd(0x80);
				twi_lcd_msg("Nueva clave:");
				twi_lcd_cmd(0xC0);
				for(uint8_t i=0;i<index;i++) twi_lcd_msg("*");
			}
		}
	}
}

int main(void){
	char clave_guardada[MAX_CLAVE+1] = {0};
	char opcion = 0;
	uint8_t intentos_fallidos = 0;

	// Inicializaciones
	twi_init();
	twi_lcd_init();
	keypad_init();

    // Configurar LEDs y buzzer
	DDRB |= (1<<PB5) | (1<<PB4) | (1<<PB6); // PB5=verde, PB4=rojo, PB6=buzzer
	PORTB &= ~((1<<PB5)|(1<<PB4)|(1<<PB6)); // apagar todos al inicio

	// Leer la clave de la EEPROM
	leer_clave_EEPROM(clave_guardada);

	// Si está vacía (0xFF), inicializar con "1234"
	if(clave_guardada[0]==0xFF){
		strcpy(clave_guardada,"1234");
		guardar_clave_EEPROM(clave_guardada);
	}

	// bienvenida
	twi_lcd_clear();
	twi_lcd_cmd(0x80);
	twi_lcd_msg("Bienvenido!");
	_delay_ms(3000);
	twi_lcd_clear();

	while(1){
		// Menú
		twi_lcd_clear();
		twi_lcd_cmd(0x80);
		twi_lcd_msg("1-Ingresar clave");
		twi_lcd_cmd(0xC0);
		twi_lcd_msg("2-Cambiar clave");

		do{
			opcion = keypad_getkey();  // espera opción válida
		}while(opcion!='1' && opcion!='2');

		if(opcion=='1'){
			if(ingresar_clave(clave_guardada, MAX_CLAVE)){
				twi_lcd_clear();
				twi_lcd_cmd(0x80);
				twi_lcd_msg("Clave correcta!");
				PORTB |= (1<<PB5);       // LED verde prendido
				PORTB &= ~((1<<PB4)|(1<<PB6)); // LED rojo y buzzer apagados
				intentos_fallidos = 0;   // resetear contador
				} else {
				twi_lcd_clear();
				twi_lcd_cmd(0x80);
				twi_lcd_msg("Clave incorrecta");
				PORTB |= (1<<PB4);       // LED rojo prendido
				PORTB &= ~(1<<PB5);      // LED verde apagado
				intentos_fallidos++;     // sumar intento fallido

				// Si llega a 3 intentos fallidos se activa el buzzer
				if(intentos_fallidos >= 3){
					PORTB |= (1<<PB6);    // buzzer prendido
					twi_lcd_clear();
					twi_lcd_cmd(0x80);
					twi_lcd_msg("Clave incorrecta");
					twi_lcd_cmd(0xC0);
					twi_lcd_msg("Alarma activada");
					_delay_ms(3500);      // sonar 3,5 segundos
					PORTB &= ~(1<<PB6);   // buzzer apagado
					intentos_fallidos = 0; // resetear contador
				}
			}
			_delay_ms(2000);
			// Apagar LEDs
			PORTB &= ~((1<<PB5)|(1<<PB4));
		}
		else if(opcion=='2'){
			cambiar_clave(clave_guardada, MAX_CLAVE);
		}

		_delay_ms(500); // retardo antes de volver al menú
	}
}
