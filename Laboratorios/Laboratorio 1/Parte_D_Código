; =================================================================
; Parte D/E: Plotter
; =================================================================
.include "m328Pdef.inc"

.equ F_CPU = 16000000                       ; Frecuencia del microcontrolador (16 MHz)
.equ BAUD_RATE = 9600                       ; Velocidad de comunicación UART (9600 baudios)
.equ UBRR_VAL = (F_CPU/16/BAUD_RATE)-1      ; Valor para configurar la UART

; Definición de pines del puerto D usados para controlar el plotter
.equ BAJA_SOLENOIDE  = 2    ; Pin PD2: activa el solenoide hacia abajo
.equ SUBIR_SOLENOIDE = 3    ; Pin PD3: activa el solenoide hacia arriba
.equ MOV_ABAJO       = 4    ; Pin PD4: motor en dirección abajo
.equ MOV_ARRIBA      = 5    ; Pin PD5: motor en dirección arriba
.equ MOV_DERECHA     = 6    ; Pin PD6: motor en dirección derecha
.equ MOV_IZQUIERDA   = 7    ; Pin PD7: motor en dirección izquierda

; Definición de registros de propósito general
.def temp = r16 ; Registro auxiliar para operaciones temporales
.def contador = r17 ; Usado como contador en rutinas
.def opcion_actual = r18 ; Guarda la opción seleccionada desde el menú

.cseg
.org 0x0000
    jmp RESET  ; Salto al vector de reset, inicio del programa

; =================================================================
; MENSAJES DEL MENU (Monitor serial)
; =================================================================
BienvenidoMsg: .db "Bienvenido al sistema de dibujo", 0x0D, 0x0A, 0
MenuMsg .db "Seleccione una opcion: ", 0x0D, 0x0A, 0
MenuOpciones .db "1: Triangulo  2: Cruz  T: Ambas figuras ", 0x0D, 0x0A, 0
FiguraMsg .db "Dibujando Figura...", 0x0D, 0x0A, 0

; =================================================================
; INICIALIZACIÓN
; =================================================================
RESET:
    ; Inicia stack pointer
    ldi temp, high(RAMEND)  ; Cargar la parte alta de la dirección final de la RAM
    out SPH, temp           ; Configurar el SPH (Stack Pointer High)
    ldi temp, low(RAMEND)   ; Cargar la parte baja de la RAM
    out SPL, temp           ; Configurar el SPL (Stack Pointer Low)

    ;Inicia UART
    ldi temp, high (UBRR_VAL)         ; Parte alta del divisor de baudios
    sts UBRR0H, temp
    ldi temp, low (UBRR_VAL)          ; Parte baja del divisor de baudios
    sts UBRR0L, temp
    ldi temp, (1<<RXEN0)|(1<<TXEN0)   ; Habilitar recepción y transmisión UART
    sts UCDR0B, temp
    ldi temp, (1<<UCSZ01)|(1<<UCSZ00) ; Formato: 8 bits de datos, 1 bit de stop
    sts UCSR0C, temp

    ; Configurar puerto D como salida (pines para mover motores y solenoide)
    ldi temp, 0b11111100  ; D2–D7 como salida, D0 y D1 quedan para RX/TX UART
    out DDRD, temp
    ldi temp, 0x00        ; Inicializar todos los pines en 0 (apagados)
    out PORTD, temp
    
    ; LED de prueba en PB5
    sbi DDRB, 5
    cbi PORTB, 5            ; Apagar LED al inicio

    clr opcion_actual       ; Limpiar la variable de opción seleccionada

    ; Asegurar que el solenoide esté SUBIDO al inicio
    call SUBIR_SOLENOIDE_COMPLETO

    ; Mostrar menú inicial en el monitor serie
    rcall MostrarMenu

    ; Pequeña espera inicial (3 segundos)
    ldi r24, low(3000)
    ldi r25, high(3000)
    rcall DELAY_MS

; =================================================================
; LOOP PRINCIPAL
; =================================================================
MAIN:
    rcall UART_CheckReceive     ; Verifica si llegó un dato por UART
    cpi opcion_actual, '1'      ; ¿Se recibió un '1'?
    breq ejecutar_triangulo     ; Sí → ir a rutina triángulo
    cpi opcion_actual, '2'      ; ¿Se recibió un '2'?
    breq ejecutar_cruz          ; Sí → ir a rutina cruz
    cpi opcion_actual, 'T'      ; ¿Se recibió 'T'?
    breq ejecutar_ambas         ; Sí → dibujar ambas figuras
    cpi opcion_actual, 't'      ; ¿Se recibió 't'?
    breq ejecutar_ambas         ; Sí → dibujar ambas figuras

    rjmp MAIN   ; Si no se recibió nada, volver a chequear

ejecutar_triangulo:
    ; LED ON, indica que el plotter está dibujando
    sbi PORTB, 5

    ; Enviar mensajes por UART
    ldi ZH, high(FiguraMsg<<1)      ; Cargar dirección de "Dibujando Figura..."
    ldi ZL, low(FiguraMsg<<1)
    rcall UART_SendString           ; Imprimir mensaje
    ldi ZH, high(TrianguloMsg<<1)   ; Cargar mensaje específico del triángulo
    ldi ZL, low(TrianguloMsg<<1)
    rcall UART_SendString           ; Imprimir mensaje

    call MOVER_AL_CENTRO           ; Mover plotter al centro antes de dibujar
    ldi r24, low(3000)             ; Delay de 3 segundos
    ldi r25, high(3000)
    rcall DELAY_MS
    call TRIANGULO                 ; Llamar a la subrutina que dibuja el triángulo
 
    ; Asegurar solenoide subido al finalizar
    call SUBIR_SOLENOIDE_COMPLETO
    
    ; LED OFF → dibujo terminado
    cbi PORTB, 5
    clr opcion_actual    ; Limpiar opción para esperar nueva selección
    rcall MostrarMenu    ; Mostrar menú otra vez
    rjmp MAIN            ; Volver al loop principal

ejecutar_cruz:
    ; LED ON, indica que el plotter está dibujando
    sbi PORTB, 5
    
    ldi ZH, high(FiguraMsg<<1)   ; "Dibujando Figura..."
    ldi ZL, low(FiguraMsg<<1)
    rcall UART_SendString
    ldi ZH, high(CruzMsg<<1)     ; Mensaje específico de la cruz
    ldi ZL, low(CruzMsg<<1)
    rcall UART_SendString

    call MOVER_AL_CENTRO         ; Mover plotter al centro antes de dibujar
    ldi r24, low(5000)           ; Delay de 5 segundos
    ldi r25, high(5000)
    rcall DELAY_MS
    call CRUZ                    ; Llamada a la subrutina que dibuja la cruz
    
    ; Asegurar solenoide subido al finalizar
    call SUBIR_SOLENOIDE_COMPLETO

    ; LED OFF → dibujo terminado
    cbi PORTB, 5
    clr opcion_actual           ; Limpiar opción para próxima selección
    rcall MostrarMenu           ; Mostrar menú otra vez
    rjmp MAIN                   ; Volver al loop principal

ejecutar_ambas:
    ; LED ON, indica que el plotter está dibujando
    sbi PORTB, 5
    
    ldi ZH, high(FiguraMsg<<1)
    ldi ZL, low(FiguraMsg<<1)
    rcall UART_SendString
    ldi ZH, high(AmbasMsg<<1)    ; Mensaje indicando que se dibujarán ambas figuras
    ldi ZL, low(AmbasMsg<<1)
    rcall UART_SendString

    ; Dibujar triángulo
    call MOVER_AL_CENTRO
    ldi r24, low(3000)
    ldi r25, high(3000)
    rcall DELAY_MS
    call TRIANGULO

    ; Volver al centro antes de dibujar la cruz
	call MOVER_AL_CENTRO
    ldi r24, low(3000)
    ldi r25, high(3000)
    rcall DELAY_MS
    call CRUZ
    
    ; Asegurar solenoide subido al finalizar
    call SUBIR_SOLENOIDE_COMPLETO
    
    ; LED OFF
    cbi PORTB, 5
    clr opcion_actual           ; Limpiar opción para próxima selección
    rcall MostrarMenu           ; Mostrar menú otra vez
    rjmp MAIN                   ; Volver al loop principal

; =================================================================
; SUBRUTINAS DE MOVIMIENTO
; =================================================================
MOVER_AL_CENTRO:
    ; Asegurar que el solenoide esté SUBIDO durante el movimiento hacia el centro
    call SUBIR_SOLENOIDE_COMPLETO

    ldi r24, low(5000)             ; Tiempo de movimiento horizontal/vertical
    ldi r25, high(5000)

    ; Mover a la izquierda
    sbi PORTD, MOV_IZQUIERDA
    rcall DELAY_MS                 ; Esperar el tiempo necesario
    cbi PORTD, MOV_IZQUIERDA
    rcall DELAY_MS

    ; Mover abajo
    sbi PORTD, MOV_ABAJO
    rcall DELAY_MS
    cbi PORTD, MOV_ABAJO

    ; Pequeña pausa final
    ldi r24, low(3000)
    ldi r25, high(3000)
    rcall DELAY_MS
    ret

SUBIR_SOLENOIDE_COMPLETO:
    ; Asegurarse de que el solenoide esté completamente subido
    cbi PORTD, BAJA_SOLENOIDE  ; Apagar bajada
    sbi PORTD, SUBIR_SOLENOIDE ; Activar subida
    ldi r24, low(3000)         ; Delay para que suba completamente
    ldi r25, high(3000)
    rcall DELAY_MS
    cbi PORTD, SUBIR_SOLENOIDE ; Apagar subida
    ret

BAJAR_SOLENOIDE_COMPLETO:
    ; Asegurarse de que el solenoide esté completamente bajado
    cbi PORTD, SUBIR_SOLENOIDE ; Apagar subida
    sbi PORTD, BAJA_SOLENOIDE  ; Activar bajada
    ldi r24, low(3000)         ; Delay suficiente para bajar
    ldi r25, high(3000)
    rcall DELAY_MS
    cbi PORTD, BAJA_SOLENOIDE  ; Apagar bajada
    ret

TRIANGULO:
    ; Activar solenoide para dibujar
    call BAJAR_SOLENOIDE_COMPLETO

    ldi r24, low(3000)
    ldi r25, high(3000)
    rcall DELAY_MS

    ; Dibujar los tres lados del triángulo
    sbi PORTD, MOV_ABAJO
    rcall DELAY_MS
    cbi PORTD, MOV_ABAJO
    rcall DELAY_MS

    sbi PORTD, MOV_IZQUIERDA
    rcall DELAY_MS
	cbi PORTD, MOV_IZQUIERDA
    rcall DELAY_MS

    sbi PORTD, MOV_DERECHA
    sbi PORTD, MOV_ARRIBA
    rcall DELAY_MS
    cbi PORTD, MOV_DERECHA
    cbi PORTD, MOV_ARRIBA
    rcall DELAY_MS

    ; Levantar lápiz al finalizar
    call SUBIR_SOLENOIDE_COMPLETO
    ret

CRUZ:
    ; Bajar solenoide para dibujar
    call BAJAR_SOLENOIDE_COMPLETO

    ldi r24, low(3000)
    ldi r25, high(3000)
    rcall DELAY_MS

    ; Dibujar cruz (vertical)
    sbi PORTD, MOV_ARRIBA
    rcall DELAY_MS
    cbi PORTD, MOV_ARRIBA
    rcall DELAY_MS

    sbi PORTD, MOV_ARRIBA
    rcall DELAY_MS
    cbi PORTD, MOV_ARRIBA
    rcall DELAY_MS

    sbi PORTD, MOV_ABAJO
    rcall DELAY_MS
    cbi PORTD, MOV_ABAJO
    rcall DELAY_MS

    sbi PORTD, MOV_ABAJO
    rcall DELAY_MS
    cbi PORTD, MOV_ABAJO
    rcall DELAY_MS

    sbi PORTD, MOV_ABAJO
    rcall DELAY_MS
    cbi PORTD, MOV_ABAJO
    rcall DELAY_MS

    sbi PORTD, MOV_ARRIBA
    rcall DELAY_MS
    cbi PORTD, MOV_ARRIBA
    rcall DELAY_MS

    ; Dibujar cruz (horizontal)
    sbi PORTD, MOV_IZQUIERDA
    rcall DELAY_MS
    cbi PORTD, MOV_IZQUIERDA
    rcall DELAY_MS

    sbi PORTD, MOV_DERECHA
    rcall DELAY_MS
    cbi PORTD, MOV_DERECHA
    rcall DELAY_MS

    sbi PORTD, MOV_DERECHA
    rcall DELAY_MS
    cbi PORTD, MOV_DERECHA
    rcall DELAY_MS

    ; Levantar lápiz al finalizar
    call SUBIR_SOLENOIDE_COMPLETO
    ret

; =================================================================
; RUTINAS UART
; =================================================================
UART_CheckReceive:
    lds temp, UCSR0A             ; Leer registro de estado UART
	sbrs temp, RXC0              ; Si no hay dato recibido, saltar siguiente instrucción
	ret                          ; Retorna si no hay dato
	lds opcion_actual, UDR0      ; Si hay dato, leerlo del buffer UART
	ret

UART_Transmit:
	lds temp, UCSR0A
	sbrs temp, UDRE0             ; Espera hasta que el buffer de transmisión esté vacío
	rjmp UART_Transmit
	sts UDR0, r18                ; Enviar el byte almacenado en r18
	ret

UART_SendString:
	lpm r18, Z+                  ; Leer byte desde memoria de programa usando puntero Z
	cpi r18, 0                   ; Comprobar si es fin de string (0)
	breq fin_str                 ; Si sí, terminar
	rcall UART_Transmit          ; Enviar byte
	rcall UART_SendString        ; Llamar recursivamente para el siguiente byte
fin_str:
	ret

MostrarMenu:
    ldi ZH, high(BienvenidoMsg<<1)
    ldi ZH, low(BienvenidoMsg<<1)
	rcall UART_SendString               ; Mostrar mensaje de bienvenida
    ldi ZH, high(MenuMsg<<1)
    ldi ZH, low(MenuMsg<<1)
	rcall UART_SendString               ; Mostrar mensaje de "Seleccione una opción"
    ldi ZH, high(MenuOpciones<<1)
    ldi ZH, low(MenuOpciones<<1)
	rcall UART_SendString               ; Mostrar las opciones disponibles
	ret

; =================================================================
; DELAY EN MILISEGUNDOS
; ================================================================
DELAY_MS:
    push r24
    push r25
    push r26
    push r27
DELAY_MS_LOOP:
    sbiw r24, 1                 ; Decrementar contador r24:r25
    brne DELAY_MS_INNER         ; Si no es cero, entrar al loop interno
    pop r27
    pop r26
    pop r25
    pop r24
    ret                         ; Retornar de la rutina cuando el contador principal llega a 0
DELAY_MS_INNER:
    ldi r26, low(16000/4)       ; Ajuste según F_CPU para 1 ms
    ldi r27, high(16000/4)
DELAY_MS_INNER_LOOP:
    sbiw r26, 1
    brne DELAY_MS_INNER_LOOP
    rjmp DELAY_MS_LOOP          ; Cuando termina el bucle interno, decrementar el contador principal

; ================================================================
; Mensajes adicionales
; ================================================================
TrianguloMsg:  .db "Triangulo seleccionado",0x0D,0x0A,0
CruzMsg:       .db "Cruz seleccionada",0x0D,0x0A,0
AmbasMsg:      .db "Ambas figuras seleccionadas",0x0D,0x0A,0
