; =================================================================
; Parte D/E: Plotter
; =================================================================
.include "m328Pdef.inc"

.equ F_CPU = 16000000
.equ BAUD_RATE = 9600
.equ UBRR_VAL = (F_CPU/16/BAUD_RATE)-1

.equ BAJA_SOLENOIDE  = 2    ; D2 - X0
.equ SUBIR_SOLENOIDE = 3    ; D3 - X1
.equ MOV_ABAJO       = 4    ; D4 - X5
.equ MOV_ARRIBA      = 5    ; D5 - X6
.equ MOV_DERECHA     = 6    ; D6 - X7
.equ MOV_IZQUIERDA   = 7    ; D7 - X10

.def temp = r16
.def contador = r17
.def opcion_actual = r18

.cseg
.org 0x0000
    jmp RESET

; =================================================================
; Mensajes del menú (Monitor serial)
; =================================================================
BienvenidoMsg: .db "Bienvenido al sistema de dibujo", 0x0D, 0x0A, 0
MenuMsg .db "Seleccione una opcion: ", 0x0D, 0x0A, 0
MenuOpciones .db "1: Triangulo  2: Cruz  T: Ambas figuras ", 0x0D, 0x0A, 0
FiguraMsg .db "Dibujando Figura...", 0x0D, 0x0A, 0


; =================================================================
; Inicialización
; =================================================================
RESET:
    ; Inicia stack pointer
    ldi temp, high(RAMEND)
    out SPH, temp
    ldi temp, low(RAMEND)
    out SPL, temp

    ;Inicia UART
    ldi temp, high (UBRR_VAL)
    sts UBRR0H, temp
    ldi temp, low (UBRR_VAL)
    sts UBRR0L, temp
    ldi temp, (1<<RXEN0)|(1<<TXEN0)
    sts UCDR0B, temp
    ldi temp, (1<<UCSZ01)|(1<<UCSZ00)
    sts UCSR0C, temp

    ; Configurar puerto D como salida
    ldi temp, 0b11111100
    out DDRD, temp
    ldi temp, 0x00
    out PORTD, temp
    
    ; LED de prueba en PB5
    sbi DDRB, 5
    cbi PORTB, 5

    clr opcion_actual

    ; Asegurar que el solenoide esté SUBIDO al inicio
    call SUBIR_SOLENOIDE_COMPLETO

    ; Mostrar menú inicial
    rcall MostrarMenu

    ldi r24, low(3000)
    ldi r25, high(3000)
    rcall DELAY_MS

; =================================================================
; LOOP PRINCIPAL
; =================================================================
MAIN:
    rcall UART_CheckReceive
    cpi opcion_actual, '1'
    breq ejecutar_triangulo
    cpi opcion_actual, '2'
    breq ejecutar_cruz
    cpi opcion_actual, 'T'
    breq ejecutar_ambas
    cpi opcion_actual, 't'
    breq ejecutar_ambas

    rjmp MAIN

ejecutar_triangulo:
    ; LED ON
    sbi PORTB, 5
    
    ldi ZH, high(FiguraMsg<<1)
    ldi ZL, low(FiguraMsg<<1)
    rcall UART_SendString
    ldi ZH, high(TrianguloMsg<<1)
    ldi ZL, low(TrianguloMsg<<1)
    rcall UART_SendString

    call MOVER_AL_CENTRO
    ldi r24, low(3000)
    ldi r25, high(3000)
    rcall DELAY_MS
    call TRIANGULO

    ; Asegurar solenoide subido al finalizar
    call SUBIR_SOLENOIDE_COMPLETO
    
    ; LED OFF
    cbi PORTB, 5
    clr opcion_actual
    rcall MostrarMenu
    rjmp MAIN

ejecutar_cruz:
    ; LED ON
    sbi PORTB, 5
    
    ldi ZH, high(FiguraMsg<<1)
    ldi ZL, low(FiguraMsg<<1)
    rcall UART_SendString
    ldi ZH, high(CruzMsg<<1)
    ldi ZL, low(CruzMsg<<1)
    rcall UART_SendString

    call MOVER_AL_CENTRO
    ldi r24, low(5000)
    ldi r25, high(5000)
    rcall DELAY_MS
    call CRUZ
    
    ; Asegurar solenoide subido al finalizar
    call SUBIR_SOLENOIDE_COMPLETO

    ; LED OFF
    cbi PORTB, 5
    clr opcion_actual
    rcall MostrarMenu
    rjmp MAIN




USART_Init:
    ; Configurar baudios
    ldi temp, high(UBRR_VAL)
    sts UBRR0H, temp
    ldi temp, low(UBRR_VAL)
    sts UBRR0L, temp

    ; Habilitar receptor e interrupción de recepción
    ldi temp, (1<<RXEN0)|(1<<RXCIE0)
    sts UCSR0B, temp

    ; Configurar formato: 8 bits, 1 stop bit, sin paridad
    ldi temp, (1<<UCSZ01)|(1<<UCSZ00)
    sts UCSR0C, temp
    ret

; INTERRUPCIÓN DE RECEPCIÓN SERIAL 
USART_RXC:
    ; Guardar registros
    push temp
    in temp, SREG
    push temp

    ; Leer dato recibido
    lds comando, UDR0

    ; Procesar comando
    cpi comando, '1'
    breq DIBUJAR_TRIANGULO
    cpi comando, '2'
    breq DIBUJAR_CIRCULO
    cpi comando, '3'
    breq DIBUJAR_CRUZ
    cpi comando, 'T'
    breq DIBUJAR_TODOS
    cpi comando, 't'
    breq DIBUJAR_TODOS

    ; Restaurar registros y retornar
USART_RXC_END:
    pop temp
    out SREG, temp
    pop temp
    reti

;FUNCIONES DE DIBUJOS

DIBUJAR_TRIANGULO:
    call TRIANGULO
    rjmp USART_RXC_END

DIBUJAR_CIRCULO:
    call CIRCULO
    rjmp USART_RXC_END

DIBUJAR_CRUZ:
    call CRUZ
    rjmp USART_RXC_END

DIBUJAR_TODOS:
    call TRIANGULO
    call DELAY_LARGO_FUNC
    call CRUZ
    call DELAY_LARGO_FUNC
    call CIRCULO
    rjmp USART_RXC_END

RESET_POSITION:
    ; Guardar registros
    push temp
    push temp2

    ; Primero: mover hacia arriba hasta tocar el límite superior
    call MOVER_ARRIBA_HASTA_LIMITE
    
    ; Segundo: mover hacia derecha hasta tocar el límite derecho  
    call MOVER_DERECHA_HASTA_LIMITE
    
    ; estamos en la posición inicial (superior derecha)
    ; Esta posición se considera (0,0) para nuestros dibujos
    
    ; Restaurar registros
    pop temp2
    pop temp
    ret

MOVER_ARRIBA_HASTA_LIMITE:
    ; Leer sensor de límite superior (asumiendo que está en PINB0)
    in temp, PINB
    andi temp, (1<<PB0)
    
    ; Si ya estamos en el límite, salir
    brne MOVER_ARRIBA_HASTA_LIMITE_END
    
    ; Mover hacia arriba continuamente
MOVER_ARRIBA_LOOP:
    sbi PORTD, MOV_ARRIBA
    call DELAY_CORTO_FUNC
    
    ; Verificar sensor
    in temp, PINB
    andi temp, (1<<PB0)
    breq MOVER_ARRIBA_LOOP  ; Continuar si no se ha alcanzado el límite
    
    ; Detener movimiento
MOVER_ARRIBA_HASTA_LIMITE_END:
    cbi PORTD, MOV_ARRIBA
    ret

MOVER_DERECHA_HASTA_LIMITE:
    ; Leer sensor de límite derecho (asumiendo que está en PINB1)
    in temp, PINB
    andi temp, (1<<PB1)
    
    ; Si ya estamos en el límite, salir
    brne MOVER_DERECHA_HASTA_LIMITE_END
    
    ; Mover hacia derecha continuamente
MOVER_DERECHA_LOOP:
    sbi PORTD, MOV_DERECHA
    call DELAY_CORTO_FUNC
    
    ; Verificar sensor
    in temp, PINB
    andi temp, (1<<PB1)
    breq MOVER_DERECHA_LOOP  ; Continuar si no se ha alcanzado el límite
    
    ; Detener movimiento
MOVER_DERECHA_HASTA_LIMITE_END:
    cbi PORTD, MOV_DERECHA
    ret

TRIANGULO:
    ; Activar solenoide (bajar lápiz)
    sbi PORTD, BAJA_SOLENOIDE
    call DELAY_CORTO_FUNC

    ; Dibujar triángulo
    call MOVER_DERECHA_LARGO
    call MOVER_ABAJO_LARGO
    call MOVER_IZQUIERDA_LARGO
    call MOVER_ARRIBA_LARGO

    ; Levantar lápiz
    cbi PORTD, BAJA_SOLENOIDE
    sbi PORTD, SUBIR_SOLENOIDE
    call DELAY_CORTO_FUNC
    cbi PORTD, SUBIR_SOLENOIDE
    ret

CRUZ:
    ; Activar solenoide (bajar lápiz)
    sbi PORTD, BAJA_SOLENOIDE
    call DELAY_CORTO_FUNC

    ; Dibujar cruz
    call MOVER_ABAJO_MEDIO
    call MOVER_ARRIBA_MEDIO
    call MOVER_DERECHA_MEDIO
    call MOVER_IZQUIERDA_MEDIO

    ; Levantar lápiz
    cbi PORTD, BAJA_SOLENOIDE
    sbi PORTD, SUBIR_SOLENOIDE
    call DELAY_CORTO_FUNC
    cbi PORTD, SUBIR_SOLENOIDE
    ret

; CÍRCULO (APROXIMACIÓN) 
CIRCULO:
    ; Activar solenoide (bajar lápiz)
    sbi PORTD, BAJA_SOLENOIDE
    call DELAY_CORTO_FUNC

    ; Dibujar círculo (aproximación con 8 segmentos)
    ldi contador, 8
CIRCULO_LOOP:
    call MOVER_DERECHA_CORTO
    call MOVER_ABAJO_CORTO
    call MOVER_IZQUIERDA_CORTO
    call MOVER_ARRIBA_CORTO
    dec contador
    brne CIRCULO_LOOP

    ; Levantar lápiz
    cbi PORTD, BAJA_SOLENOIDE
    sbi PORTD, SUBIR_SOLENOIDE
    call DELAY_CORTO_FUNC
    cbi PORTD, SUBIR_SOLENOIDE
    ret

; FUNCIONES DE MOVIMIENTO 
MOVER_DERECHA_CORTO:
    sbi PORTD, MOV_DERECHA
    call DELAY_CORTO_FUNC
    cbi PORTD, MOV_DERECHA
    ret

MOVER_IZQUIERDA_CORTO:
    sbi PORTD, MOV_IZQUIERDA
    call DELAY_CORTO_FUNC
    cbi PORTD, MOV_IZQUIERDA
    ret

MOVER_ARRIBA_CORTO:
    sbi PORTD, MOV_ARRIBA
    call DELAY_CORTO_FUNC
    cbi PORTD, MOV_ARRIBA
    ret

MOVER_ABAJO_CORTO:
    sbi PORTD, MOV_ABAJO
    call DELAY_CORTO_FUNC
    cbi PORTD, MOV_ABAJO
    ret

MOVER_DERECHA_MEDIO:
    sbi PORTD, MOV_DERECHA
    call DELAY_MEDIO_FUNC
    cbi PORTD, MOV_DERECHA
    ret

MOVER_IZQUIERDA_MEDIO:
    sbi PORTD, MOV_IZQUIERDA
    call DELAY_MEDIO_FUNC
    cbi PORTD, MOV_IZQUIERDA
    ret

MOVER_ARRIBA_MEDIO:
    sbi PORTD, MOV_ARRIBA
    call DELAY_MEDIO_FUNC
    cbi PORTD, MOV_ARRIBA
    ret

MOVER_ABAJO_MEDIO:
    sbi PORTD, MOV_ABAJO
    call DELAY_MEDIO_FUNC
    cbi PORTD, MOV_ABAJO
    ret

MOVER_DERECHA_LARGO:
    sbi PORTD, MOV_DERECHA
    call DELAY_LARGO_FUNC
    cbi PORTD, MOV_DERECHA
    ret

MOVER_IZQUIERDA_LARGO:
    sbi PORTD, MOV_IZQUIERDA
    call DELAY_LARGO_FUNC
    cbi PORTD, MOV_IZQUIERDA
    ret

MOVER_ARRIBA_LARGO:
    sbi PORTD, MOV_ARRIBA
    call DELAY_LARGO_FUNC
    cbi PORTD, MOV_ARRIBA
    ret

MOVER_ABAJO_LARGO:
    sbi PORTD, MOV_ABAJO
    call DELAY_LARGO_FUNC
    cbi PORTD, MOV_ABAJO
    ret


; FUNCIONES DE DELAY 
DELAY_CORTO_FUNC:
    ldi r24, low(DELAY_CORTO)
    ldi r25, high(DELAY_CORTO)
    rcall DELAY_MS
    ret

DELAY_MEDIO_FUNC:
    ldi r24, low(DELAY_MEDIO)
    ldi r25, high(DELAY_MEDIO)
    rcall DELAY_MS
    ret

DELAY_LARGO_FUNC:
    ldi r24, low(DELAY_LARGO)
    ldi r25, high(DELAY_LARGO)
    rcall DELAY_MS
    ret

; DELAY EN MILISEGUNDOS CH
DELAY_MS:
    push r24
    push r25
    push r26
DELAY_MS_LOOP:
    sbiw r24, 1
    brne DELAY_MS_LOOP_INNER
    pop r26
    pop r25
    pop r24
    ret

DELAY_MS_LOOP_INNER:
    ldi r26, 200
DELAY_MS_INNER:
    dec r26
    brne DELAY_MS_INNER
    rjmp DELAY_MS_LOOP





