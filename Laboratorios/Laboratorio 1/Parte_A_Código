; =================================================================
; Parte A: Cinta transportadora con Punzonadora
; =================================================================
.include "m328pdef.inc"

.def TEMP          = r16
.def ESTADO        = r17        ; Estado actual del sistema (0–4, 35)
.def PD_ANT        = r18        ; Entradas previas de los pulsadores
.def AN            = r19        ; Entradas actuales de los pulsadores
.def CARGA_ELEGIDA = r20        ; Selección de carga (0 = ninguna, 1–3)
.def CONTADOR      = r21        ; Contador para temporizaciones
.def USART_TEMP    = r22        ; Registro temporal para USART
.def ESTADO_ANT    = r23        ; Último estado mostrado en USART

.cseg
.org 0x0000
    rjmp inicio

inicio:
    ; Configuración de puertos, LEDs y entradas igual que antes
    ldi TEMP, 0x3F
    out DDRB, TEMP    ; Configura PB0-PB5 como salida (LEDs, actuadores)
    sbi DDRC, 0
    sbi DDRC, 1
    sbi DDRC, 3
    cbi DDRC, 2    ; Configura PC0, PC1, PC3 como salida; PC2 entrada
    sbi PORTC, 2    ; Pull-up para PC2 (entrada)
    ldi TEMP, 0x01
    out PORTB, TEMP
    ldi ESTADO, 0
    ldi CARGA_ELEGIDA, 0
    cbi DDRD, 2
    cbi DDRD, 3
    cbi DDRD, 4
    cbi DDRD, 5
    cbi DDRD, 6
    sbi PORTD, 2
    sbi PORTD, 3
    sbi PORTD, 4
    sbi PORTD, 5
    sbi PORTD, 6
    in PD_ANT, PIND
    andi PD_ANT, 0x7C    ; Lee entradas de PD2 a PD6
    ldi TEMP, (1<<CS02)|(1<<CS00)
    out TCCR0B, TEMP    ; Prescaler de Timer0 para temporización
    ldi TEMP, 0
    out TCNT0, TEMP    ; Inicializa contador a 0        
    ldi ESTADO_ANT, 255

    ; Inicializar USART
    rcall USART_Init    ; Inicializa comunicación serie

    ; Enviar mensaje de inicio
    ldi ZL, LOW(mensaje_inicio<<1)
    ldi ZH, HIGH(mensaje_inicio<<1)
    rcall USART_SendString

main_loop:
    ; Leer USART y pulsadores
    rcall USART_CheckReceive    ; Comprueba si llegó un carácter por USART
    in AN, PIND
    andi AN, 0x7C    ; Lee pulsadores PD2 a PD6

    ; Actualizar estado si cambió
    rcall check_estado    


; ---------------- Estado 0: Espera inicial y activación con pulsador PD2 ---------------- 

    cpi ESTADO, 0
    brne estado1
    sbis PIND, 2
    rjmp main_loop
    sbrc PD_ANT, 2
    rjmp main_loop
    ldi ESTADO, 1
    rcall actualizar_leds
    rjmp main_loop
; ---------------- Estado 1: seleccionar carga ----------------
estado1:
    cpi ESTADO, 1
    brne estado2

 ; --- Selección de carga mediante pulsadores ---
    cpi CARGA_ELEGIDA, 0
    brne main_loop

    sbis PIND, 3    ; Si pulsador PD3 no presionado, salta
    rjmp check_pd4
    sbrc PD_ANT, 3    ; Evita rebote
    rjmp check_pd4
    ldi CARGA_ELEGIDA, 1    ; Si se presionó PD3, selecciona carga 1
    rjmp carga_elegida_usart

check_pd4:
    sbis PIND, 4    ; Si PD4 no presionado, salta a check_pd5
    rjmp check_pd5
    sbrc PD_ANT, 4
    rjmp check_pd5
    ldi CARGA_ELEGIDA, 2    ; Selección de carga 2
    rjmp carga_elegida_usart

check_pd5:
    sbis PIND, 5    ; Si PD5 no presionado, vuelve al main_loo
    rjmp main_loop
    sbrc PD_ANT, 5
    rjmp main_loop
    ldi CARGA_ELEGIDA, 3    ; Si se presionó PD5, selecciona carga 3

carga_elegida_usart:
    rcall actualizar_leds    ; Actualiza los LEDs según la carga seleccionada
    ldi ESTADO, 2    ; Cambia al estado 2
    rjmp main_loop    ; Vuelve al bucle principal

; ---------------- Estado 2: encender PB5 según carga y esperar PD6 ----------------
estado2:
    cpi ESTADO, 2    ; Compara si el estado actual es 2
    brne estado3    ; Si no es 2, salta al siguiente estado (estado3)

    sbis PINC, 2    ; Si PC2 está en bajo, salta la siguiente instrucción
    rjmp main_loop    ; Volver al bucle principal mientras PC2 no se active

    ; --- Encender PB5 según carga ---
    cpi CARGA_ELEGIDA,1    ; Compara si la carga seleccionada es 1
    brne carga2    ; Si no es 1, pasa al siguiente caso (carga2)
    sbi PORTB,5    ; Enciende PB5 (actuador o LED)
    ldi CONTADOR,3    ; Carga el contador para temporización
    rcall espera_multi     ; Espera múltiple (3 segundos)
    cbi PORTB,5    ; Apaga PB5
    ldi CONTADOR,2     ; Carga contador para nueva espera
    rcall espera_multi    ; Espera adicional (2 segundos)
    rjmp espera_pd6     ; Salta a esperar pulsador PD6

carga2:
    cpi CARGA_ELEGIDA,2    ; Compara si la carga es 2
    brne carga3
    sbi PORTB,5
    ldi CONTADOR,4
    rcall espera_multi
    cbi PORTB,5
    ldi CONTADOR,2    ;espera 2
    rcall espera_multi
    rjmp espera_pd6

carga3:
    cpi CARGA_ELEGIDA,3    ; Compara si la carga es 3
    brne espera_pd6
    sbi PORTB,5
    ldi CONTADOR,5
    rcall espera_multi
    cbi PORTB,5
    ldi CONTADOR,3    ;espera 3
    rcall espera_multi

espera_pd6:
    sbis PIND,6    ; Si PD6 está en bajo, salta la siguiente instrucción
    rjmp espera_pd6     ; Mientras no se presione PD6, espera en bucle
    ldi ESTADO,3     ; Cuando PD6 se activa, cambia al estado 3 (punzonadora)
    rcall actualizar_leds    ; Actualiza LEDs según el nuevo estado
    rjmp main_loop     ; Vuelve al bucle principal

; ---------------- Estado 3: punzonadora ----------------
estado3:
    cpi ESTADO,3    ; Compara si el estado actual es 3
    brne estado35    ; Si no es 3, salta al siguiente estado (estado35 -> estado 4)
    ; Primer pulso
    sbi PORTC,0
    ldi CONTADOR,1
    rcall espera_multi
    ; Espera según carga
    cpi CARGA_ELEGIDA,1
    cbi PORTC,0
    brne c2e
    ldi CONTADOR,2    ;espera 2
    rcall espera_multi
    rjmp pulso2
c2e:
    cpi CARGA_ELEGIDA,2
    brne c3e
    cbi PORTC,0
    ldi CONTADOR,2    ;espera 2
    rcall espera_multi
    rjmp pulso2
c3e:
    cpi CARGA_ELEGIDA,3
    brne fin_e3
    cbi PORTC,0
    ldi CONTADOR,3    ;espera 3
    rcall espera_multi
    rjmp pulso2
fin_e3:
; --- Segundo pulso de la punzonadora ---
pulso2:
    sbi PORTC,0    ; Enciende nuevamente el actuador (PC0)
    ldi CONTADOR,1
    rcall espera_multi
    cbi PORTC,0
    ldi CONTADOR,1
    rcall espera_multi
 ; --- Finaliza estado 3 y pasa al siguiente ---
    ldi ESTADO,35
    rcall actualizar_leds
    rjmp main_loop

; ---------------- Estado 4: avance PB ----------------
estado35:
    cpi ESTADO,35    ; Compara si el estado actual es 35 (estado 4)
    brne estado4    ; Si no es 35, salta al siguiente estado (estado4--> estado 5)
; --- Control del avance de la cinta según carga ---
    cpi CARGA_ELEGIDA,1    ; Si la carga seleccionada es 1
    brne c2a    ; Si no, salta al siguiente caso
    sbi PORTC,3    ; Activa el motor/actuador de avance (PC3)
    ldi CONTADOR,2    ;espera 2
    rcall espera_multi
    cbi PORTC,3
    rjmp fin_e35    ; Salta al final del estado
c2a:
    cpi CARGA_ELEGIDA,2    ; Si la carga es 2
    brne c3a
    sbi PORTC,3
    ldi CONTADOR,3    ;espera 3
    rcall espera_multi
    cbi PORTC,3
    rjmp fin_e35
c3a:
    cpi CARGA_ELEGIDA,3    ; Si la carga es 3
    brne fin_e35
    sbi PORTC,3
    ldi CONTADOR,4    ;espera 4
    rcall espera_multi
    cbi PORTC,3
    cbi PORTB,5
fin_e35:
    ldi ESTADO,4
    rcall actualizar_leds
    rjmp main_loop

; ---------------- Estado 5: LED final ----------------
estado4:
 ; --- Apagar todos los LEDs indicadores de carga ---
    cbi PORTB,0
    cbi PORTB,1
    cbi PORTB,2
    cbi PORTB,3
    cbi PORTB,4
  ; --- Encender LED de finalización del ciclo ---
    sbi PORTC,1
; --- Espera de 5 segundos con temporizador ---
    ldi CONTADOR,5
espera_final:
    rcall espera_1s
    dec CONTADOR
    brne espera_final
    ; --- Apagar LED de finalización y reiniciar sistema ---
    cbi PORTC,1
    ldi ESTADO,0
    ldi CARGA_ELEGIDA,0
    rcall actualizar_leds
    rjmp main_loop

; ---------------- Rutinas auxiliares ----------------
actualizar_leds:
    cpi ESTADO,0
    breq leds0
    cbi PORTB,0
    sbi PORTB,1
    cpi CARGA_ELEGIDA,1
    brne ce2
    sbi PORTB,2
    rjmp fin_led
ce2:
    cpi CARGA_ELEGIDA,2
    brne ce3
    sbi PORTB,3
    rjmp fin_led
ce3:
    cpi CARGA_ELEGIDA,3
    brne fin_led
    sbi PORTB,4
fin_led:
    ret

leds0:
    cbi PORTB,1
    cbi PORTB,2
    cbi PORTB,3
    cbi PORTB,4
    sbi PORTB,0
    ret

espera_multi:
    rcall espera_1s     ; Llama a la rutina que espera aproximadamente 1 segundo
    dec CONTADOR    ; Decrementa el contador de repeticiones
    brne espera_multi    ; Si el contador no llegó a 0, repite la espera
    ret    ; Retorna al llamador cuando el contador llega a 0

espera_1s:
    ldi r17,0    ; Inicializa un registro temporal r17 a 0 para contar ciclos de temporizador
e1s:
    sbis TIFR0,TOV0    ; Espera hasta que el flag TOV0 del Timer0 esté seteado (desbordamiento)
    rjmp e1s     ; Si no está seteado, sigue esperando
    ldi r16,(1<<TOV0)    ; Prepara el valor para limpiar el flag TOV0
    out TIFR0,r16    ; Limpia el flag TOV0 escribiendo un 1 en él
    inc r17    ; Incrementa el contador de ciclos
    cpi r17,61    ; Compara si se completaron 61 ciclos (aprox. 1 segundo)
    brne e1s     ; Si no se completaron, vuelve a esperar
    ret    ; Retorna al llamador cuando se completó la espera de 1 segundo

; ---------------- USART----------------
USART_Init:
    ldi r16, HIGH(103)
    sts UBRR0H, r16
    ldi r16, LOW(103)
    sts UBRR0L, r16
    ldi r16, (1<<RXEN0)|(1<<TXEN0)
    sts UCSR0B, r16
    ldi r16, (3<<UCSZ00)    ; 8 bits
    sts UCSR0C, r16
    ret

USART_Transmit:
    lds USART_TEMP, UCSR0A
    sbrs USART_TEMP, UDRE0
    rjmp USART_Transmit
    sts UDR0, r16
    ret

; Devuelve en r16 el carácter recibido o 0 si no hay dato
USART_Receive:
    lds USART_TEMP, UCSR0A
    sbrs USART_TEMP, RXC0     ; si RXC0=1 -> salta la siguiente instrucción
    rjmp usart_no_data        ; si no está set -> no hay dato -> saltar
    lds r16, UDR0            ; leer dato recibido
    ret
usart_no_data:
    ldi r16, 0
    ret

; Leer string desde FLASH (lpm) usando Z (Z debe cargarse con msg<<1)
USART_SendString:
next_char:
    lpm r16, Z+              ; leer byte de flash e incrementar Z
    cpi r16, 0
    breq end_string
    rcall USART_Transmit
    rjmp next_char
end_string:
    ret

; Comprueba si llegó un carácter y lo procesa
USART_CheckReceive:
    push r16
    rcall USART_Receive
    cpi r16, 0
    breq fin_usart

    ; Reinicio
    cpi r16, 'R'
    breq reiniciar_estado

    ; Solo aceptar 'A' en estado 0
    cpi r16, 'A'
    brne check_carga
    cpi ESTADO, 0
    brne fin_usart
    ldi ESTADO, 1
    sbi PORTB,1         
    rcall actualizar_leds
    rjmp fin_usart

check_carga:
    ; Solo aceptar carga en estado 1
    cpi ESTADO, 1
    brne fin_usart
    cpi r16, '1'
    breq carga1_usart
    cpi r16, '2'
    breq carga2_usart
    cpi r16, '3'
    breq carga3_usart
    rjmp fin_usart

carga1_usart:
    ldi CARGA_ELEGIDA, 1
    rjmp fin_carga_usart
carga2_usart:
    ldi CARGA_ELEGIDA, 2
    rjmp fin_carga_usart
carga3_usart:
    ldi CARGA_ELEGIDA, 3

fin_carga_usart:
    rcall actualizar_leds
    ldi ESTADO, 2
fin_usart:
    pop r16
    ret

reiniciar_estado:
    ldi ESTADO, 0
    ldi CARGA_ELEGIDA, 0
    rcall actualizar_leds
    pop r16
    ret

; ---------------- check_estado: imprime solo si cambió ----------------
check_estado:
    push r16
    cp ESTADO, ESTADO_ANT
    breq chk_end
    mov ESTADO_ANT, ESTADO

    cpi ESTADO, 0
    breq ch0
    cpi ESTADO, 1
    breq ch1
    cpi ESTADO, 2
    breq ch2
    cpi ESTADO, 3
    breq ch3
    cpi ESTADO, 35
    breq ch35
    cpi ESTADO, 4
    breq ch4
    rjmp chk_end

ch0:
    ldi ZL, LOW(msg_estado0<<1)
    ldi ZH, HIGH(msg_estado0<<1)
    rcall USART_SendString
    rjmp chk_end
ch1:
    ldi ZL, LOW(msg_estado1<<1)
    ldi ZH, HIGH(msg_estado1<<1)
    rcall USART_SendString
    rjmp chk_end
ch2:
    ldi ZL, LOW(msg_estado2<<1)
    ldi ZH, HIGH(msg_estado2<<1)
    rcall USART_SendString
    rjmp chk_end
ch3:
    ldi ZL, LOW(msg_estado3<<1)
    ldi ZH, HIGH(msg_estado3<<1)
    rcall USART_SendString
    rjmp chk_end
ch35:
    ldi ZL, LOW(msg_estado35<<1)
    ldi ZH, HIGH(msg_estado35<<1)
    rcall USART_SendString
    rjmp chk_end
ch4:
    ldi ZL, LOW(msg_estado4<<1)
    ldi ZH, HIGH(msg_estado4<<1)
    rcall USART_SendString
    rjmp chk_end

chk_end:
    pop r16
    ret

; ---------------- Mensajes ----------------
mensaje_inicio: .db "USART activo", 0x0D, 0x0A, 0
msg_estado0:	.db "Estado 0", 0x0D, 0x0A, 0
msg_estado1:	.db "Estado 1", 0x0D, 0x0A, 0
msg_estado2:	.db "Estado 2", 0x0D, 0x0A, 0
msg_estado3:	.db "Estado 3", 0x0D, 0x0A, 0
msg_estado35:	.db "Estado 4", 0x0D, 0x0A, 0
msg_estado4:	.db "Estado 5", 0x0D, 0x0A, 0
