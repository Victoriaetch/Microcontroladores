#define F_CPU 16000000UL
#include <avr/io.h>
#include <util/delay.h>
#include <stdio.h>
#include <stdint.h>

#include <avr/eeprom.h>
#include <string.h>
#include <avr/interrupt.h>   // <- importante para ISR()


#include "UART.h"
#include "SPI.h"
#include "RC522.h"
#include "TWI.h"
#include "i2c_lcd.h"
 
 
#define BAUD 9600
#define MY_UBRR F_CPU/16/BAUD-1

#define LCD_BACKLIGHT_ON  1
#define LCD_BACKLIGHT_OFF 0


//REVISAR PINES 
#define LED_VERDE PB0
#define LED_ROJO PB1
#define BTN_BORRAR PD2
#define BTN_UPDATE PD3   

//EEPROM ALMACENA EL UID DE LA TARJETA AUTORIZADA (5BYTES)
uint8_t eeprom_uid[10] EEMEM;

//PROTOTIPOS DE FUNCIONES AUXILIARES (revisar)
void leds_init (void);
void botones_init(void);
void interrupciones_init(void);

void read_stored_uid(uint8_t *buf);
void write_stored_uid(const uint8_t *buf);
void clear_stored_uid(void);

uint8_t uid_vacio (const uint8_t *buf);
void display_and_log(const char *l1, const char *l2, const char *msg);

//IMPLEMENTACIONES FUNCIONES AUXILIARES
void leds_init (void) {
	DDRB |= (1<<LED_VERDE) | (1<<LED_ROJO);
	PORTB &= ~((1<<LED_VERDE) | (1<<LED_ROJO));
}

void botones_init(void) {
	DDRD &= ~((1<<BTN_BORRAR) | (1<<BTN_UPDATE));
	PORTD |= (1<<BTN_BORRAR) | (1<<BTN_UPDATE); // pull-ups internos
}

void interrupciones_init(void) {
	// Configura INT0 e INT1 para flanco descendente (cuando se presiona el botón)
	EICRA |= (1 << ISC01) | (1 << ISC11);
	EICRA &= ~((1 << ISC00) | (1 << ISC10));
	
	// Habilita interrupciones INT0 e INT1
	EIMSK |= (1 << INT0) | (1 << INT1);
	
	// Habilita interrupciones globales
	sei();
}




//revisar estas 3 (si no funciona usar las del doc
void read_stored_uid(uint8_t *buf) {
	eeprom_read_block((void*)buf, (const void*)eeprom_uid, 10);
}

void write_stored_uid(const uint8_t *buf) {
	eeprom_update_block((const void*)buf, (void*)eeprom_uid, 10);
}

void clear_stored_uid(void) {
	uint8_t clear[10];  // revisar si es 5 o 10
	for (uint8_t i=0; i<10; i++) 
		clear[i]=0xFF;
	write_stored_uid(clear); //revisar esta tmb
	
}



uint8_t uid_vacio(const uint8_t *buf) {
	for (uint8_t i=0; i<10; i++) {	
	if (buf[i]!=0xFF && buf[i]!=0x00) {
		return 0; }
	}
	return 1;
}

void display_and_log(const char *l1, const char *l2, const char *msg) { //revisar si estan declaradas l1 y l2
	twi_lcd_clear();
	twi_lcd_cmd(0x80); // Cursor fila 0, col 0
	twi_lcd_msg(l1);
	twi_lcd_cmd(0xC0); // Cursor fila 1, col 0 (si querías ir a segunda fila)
	twi_lcd_msg(l2);
	if (msg) {
		uart_print(msg);
		uart_print("\r\n");
	}
}

	
//MAIN
int main(void)
{
	uart_init(MY_UBRR);	
	spi_init();
	leds_init();
	botones_init();
	interrupciones_init();   // <--- NUEVO
	twi_lcd_init(LCD_BACKLIGHT_ON); //A CHEQUEAR
	mfrc522_resetPinInit();
	_delay_ms(100); 
	mfrc522_init();

	uart_print("Sistema Cerradura RFID iniciado\r\n");
	display_and_log("Bienvenido al", "sistema RFID", "Bienvenido al sistema RFID"); //REVISAR
	_delay_ms(1500);
	twi_lcd_clear();
	twi_lcd_cmd(0x80); // Cursor fila 0, col 0
	twi_lcd_msg("Acerque su tarjeta");
	twi_lcd_cmd(0xC0); // Cursor fila 1, col 0 (si querías ir a segunda fila)
	twi_lcd_msg("para acceder");
	
    uint8_t stored_uid[10]; 
    read_stored_uid(stored_uid);

    uint8_t card_uid[10] = {0};

    while (1) 
    {
	// ===== VERIFICAR TARJETA ===== //
	memset(card_uid,0,sizeof(card_uid));
	mfrc522_standard(card_uid);
	if (card_uid[0]!=0) {
		uart_print("Tarjeta detectada: ");
		uart_print_hex_array(card_uid,5);

		if (uid_vacio(stored_uid)) {
			display_and_log("Sin tarjeta","registrada","No hay tarjeta registrada");
			PORTB |= (1<<LED_ROJO);
			_delay_ms(1000);
			PORTB &= ~(1<<LED_ROJO);
			twi_lcd_clear();
			twi_lcd_cmd(0x80); // Cursor fila 0, col 0
			twi_lcd_msg("Acerque tarjeta");
			twi_lcd_cmd(0xC0); // Cursor fila 1, col 0 (si querías ir a segunda fila)
			twi_lcd_msg("para registro");
			continue;
		}

		if (memcmp(card_uid,stored_uid,5)==0) {
			// Tarjeta autorizada
			PORTB |= (1<<LED_VERDE);
			display_and_log("Acceso","permitido","Acceso permitido");
			_delay_ms(2000);
			PORTB &= ~(1<<LED_VERDE);
			} else {
			PORTB |= (1<<LED_ROJO);
			display_and_log("Acceso","denegado","Acceso denegado");
			_delay_ms(1500);
			PORTB &= ~(1<<LED_ROJO);
		}

		twi_lcd_clear();
		twi_lcd_cmd(0x80); // Cursor fila 0, col 0
		twi_lcd_msg("Acerque tarjeta");
		twi_lcd_cmd(0xC0); // Cursor fila 1, col 0 (si querías ir a segunda fila)
		twi_lcd_msg("para acceso");
	}

	_delay_ms(250);
	
	}
}

//RUTINAS DE INTERRUPCION

ISR(INT0_vect) { // BOTÓN BORRAR
	_delay_ms(50); // anti-rebote simple
	clear_stored_uid();
	display_and_log("Tarjeta borrada", "", "Tarjeta borrada");
	PORTB |= (1<<LED_ROJO);
	_delay_ms(800);
	PORTB &= ~(1<<LED_ROJO);
	twi_lcd_clear();
	twi_lcd_cmd(0x80);
	twi_lcd_msg("Acerque tarjeta");
	twi_lcd_cmd(0xC0);
	twi_lcd_msg("para registrar");
}

ISR(INT1_vect) { // BOTÓN ACTUALIZAR
	_delay_ms(50); // anti-rebote simple
	display_and_log("Modo registro", "Acerque tarjeta", "Modo registro");
	uint8_t card_uid[10] = {0};
	uint8_t stored_uid[10];
	uint16_t timeout = 0;
	uint8_t nueva = 0;
	
	while (timeout < 10000) {
		memset(card_uid, 0, sizeof(card_uid));
		mfrc522_standard(card_uid);
		if (card_uid[0] != 0) {
			write_stored_uid(card_uid);
			memcpy(stored_uid, card_uid, 5);
			uart_print("Nueva tarjeta guardada: ");
			uart_print_hex_array(card_uid, 5);
			display_and_log("Nueva tarjeta", "registrada", "Tarjeta registrada");
			nueva = 1;
			_delay_ms(1000);
			break;
		}
		_delay_ms(200);
		timeout += 200;
	}

	if (!nueva) {
		display_and_log("Registro cancelado", "", "Registro: timeout");
		_delay_ms(800);
	}
	twi_lcd_clear();
	twi_lcd_cmd(0x80);
	twi_lcd_msg("Acerque tarjeta");
	twi_lcd_cmd(0xC0);
	twi_lcd_msg("para acceso");
}


