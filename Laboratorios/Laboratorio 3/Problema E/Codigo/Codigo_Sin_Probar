#define F_CPU 16000000UL
#include <avr/io.h>
#include <util/delay.h>
#include <stdio.h>
#include <stdint.h>

#include <avr/eeprom.h>
#include <string.h>
#include <avr/interrupt.h>  


#include "UART.h"
#include "SPI.h"
#include "RC522.h"
#include "TWI.h"
#include "i2c_lcd.h"
 
 
#define BAUD 9600
#define MY_UBRR F_CPU/16/BAUD-1

#define LCD_BACKLIGHT_ON  1
#define LCD_BACKLIGHT_OFF 0

#define LED_VERDE PD6
#define LED_ROJO PD7
#define BTN_BORRAR PD2
#define BTN_UPDATE PD3   

#define UID_LEN 10 

//EEPROM 
uint8_t eeprom_uid[UID_LEN] EEMEM;

//PROTOTIPOS DE FUNCIONES AUXILIARES 
void leds_init (void);
void botones_init(void);
void interrupciones_init(void);

void read_stored_uid(uint8_t *buf);
void write_stored_uid(const uint8_t *buf);
void clear_stored_uid(void);

uint8_t uid_vacio (const uint8_t *buf);
void display_and_log(const char *l1, const char *l2, const char *msg);

void handle_registration(void);
void handle_erase(void) ;

//IMPLEMENTACIONES FUNCIONES AUXILIARES
void leds_init (void) {
	DDRD |= (1<<LED_VERDE) | (1<<LED_ROJO);
	PORTD &= ~((1<<LED_VERDE) | (1<<LED_ROJO));
}

void botones_init(void) {
	DDRD &= ~((1<<BTN_BORRAR) | (1<<BTN_UPDATE));
	PORTD |= (1<<BTN_BORRAR) | (1<<BTN_UPDATE); // pull-ups internos
}

void interrupciones_init(void) {
	// Configura INT0 e INT1 para flanco descendente (cuando se presiona el botón)
	EICRA |= (1 << ISC01) | (1 << ISC11);
	EICRA &= ~((1 << ISC00) | (1 << ISC10));
	
	// Habilita interrupciones INT0 e INT1
	EIMSK |= (1 << INT0) | (1 << INT1);
	
	// Habilita interrupciones globales
	sei();
}


void read_stored_uid(uint8_t *buf) {
	eeprom_read_block((void*)buf, (const void*)eeprom_uid, UID_LEN);
}

void write_stored_uid(const uint8_t *buf) {
	eeprom_update_block((const void*)buf, (void*)eeprom_uid, UID_LEN);
}

void clear_stored_uid(void) {
	uint8_t clear[UID_LEN];
	for (uint8_t i = 0; i < UID_LEN; i++) clear[i] = 0xFF;
	write_stored_uid(clear);
}



uint8_t uid_vacio(const uint8_t *buf) {
for (uint8_t i = 0; i < UID_LEN; i++) {
		if (buf[i] != 0xFF && buf[i] != 0x00) return 0;
	}
	return 1;
}

void display_and_log(const char *l1, const char *l2, const char *msg) { 
	twi_lcd_clear();
	twi_lcd_cmd(0x00); // Cursor fila 0, col 0
	twi_lcd_msg(l1);
	twi_lcd_cmd(0xC0); // Cursor fila 1, col 0 
	twi_lcd_msg(l2);
	if (msg) {
		uart_print(msg);
		uart_print("\r\n");
	}
}

void handle_registration(void) {
	display_and_log("Modo registro", "Acerque tarjeta", "Modo registro");
	uint8_t card_uid[UID_LEN] = {0};
	uint8_t nueva = 0;
	uint32_t timeout_ms = 0;
	const uint32_t max_timeout_ms = 10000; // 10 s

	while (timeout_ms < max_timeout_ms) {
		memset(card_uid, 0, UID_LEN);
		mfrc522_standard(card_uid); // llama SPI OK desde main
		if (card_uid[0] != 0) {
			write_stored_uid(card_uid);
			uart_print("Nueva tarjeta guardada: ");
			uart_print_hex_array(card_uid, UID_LEN);
			display_and_log("Nueva tarjeta","registrada","Tarjeta registrada");
			nueva = 1;
			break;
		}
		_delay_ms(200);
		timeout_ms += 200;
	}

	if (!nueva) {
		display_and_log("Registro","Cancelado","Registro: timeout");
	}
	_delay_ms(800);
	display_and_log("Acerque tarjeta","para acceso", NULL);
}

void handle_erase(void) {
	clear_stored_uid();
	display_and_log("Tarjeta", "borrada", "Tarjeta borrada");
	PORTD |= (1<<LED_ROJO);
	_delay_ms(5000);
	PORTD &= ~(1<<LED_ROJO);
	display_and_log("Acerque tarjeta","para acceso","");
}

//MAIN
int main(void)
{
	uart_init(MY_UBRR);	
	spi_init();
	leds_init();
	botones_init();
	interrupciones_init();   
	twi_lcd_init(LCD_BACKLIGHT_ON); 
	mfrc522_resetPinInit();
	_delay_ms(100); 
	mfrc522_init();

	uart_print("Sistema Cerradura RFID iniciado\r\n");
	display_and_log("Bienvenido al", "sistema RFID", "Bienvenido al sistema RFID"); //REVISAR
	_delay_ms(3000);

	uint8_t stored_uid[UID_LEN];
	uint8_t card_uid[UID_LEN] = {0};
	read_stored_uid(stored_uid);

    display_and_log("Acerque tarjeta", "para acceder", NULL);

    while (1) 
    {
    // Si un ISR marcó flag, lo atiendo aquí en main
	if (flag_actualizar) {
	    flag_actualizar = 0;
	    handle_registration();
		read_stored_uid(stored_uid); // actualizar copia en RAM
	}
	if (flag_borrar) {
		flag_borrar = 0;
		handle_erase();
		read_stored_uid(stored_uid);
	}

// lectura normal de tarjeta
	memset(card_uid,0,sizeof(card_uid));
	mfrc522_standard(card_uid);

	if (card_uid[0]!=0) {
		uart_print("Tarjeta detectada: ");
		uart_print_hex_array(card_uid, UID_LEN);
		_delay_ms(1500);

		if (uid_vacio(stored_uid)) {
			display_and_log("Sin tarjeta","registrada","No hay tarjeta registrada");
			PORTD |= (1<<LED_ROJO);
			_delay_ms(1500);
			PORTD &= ~(1<<LED_ROJO);
		}

			  else if (memcmp(card_uid, stored_uid, UID_LEN) == 0) {
				  PORTD |= (1<<LED_VERDE);
				  display_and_log("Acceso","permitido!","Acceso permitido!!");
				  _delay_ms(5000);
				  PORTD &= ~(1<<LED_VERDE);

				  } else {
				  PORTD |= (1<<LED_ROJO);
				  display_and_log("Acceso","denegado!","Acceso denegado");
				  _delay_ms(5000);
				  PORTD &= ~(1<<LED_ROJO);
			  }

			  // esperar hasta que tarjeta se retire
			  while (1) {
				  memset(card_uid, 0, UID_LEN);
				  mfrc522_standard(card_uid);
				  if (card_uid[0] == 0) break;
				  _delay_ms(500);
			  }
		  }

		  _delay_ms(1000); // pausa entre lecturas normal
		      display_and_log("Acerque tarjeta", "para acceder", NULL);

	  }
  }

//RUTINAS DE INTERRUPCION
ISR(INT0_vect) { // BORRAR
	// Simple debounce y set flag
	_delay_ms(200);
	if (!(PIND & (1<<BTN_BORRAR))) { // SI sigue presionado
		flag_borrar = 1;
	}
}

ISR(INT1_vect) { // ACTUALIZAR (entrar en modo registro desde el main)
	_delay_ms(200);
	if (!(PIND & (1<<BTN_UPDATE))) {
		flag_actualizar = 1;
	}
}
